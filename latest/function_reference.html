<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Summary and function reference · JuliaImages</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="JuliaImages logo"/></a><h1>JuliaImages</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="install.html">Getting started: Installation and testing your install</a></li><li><a class="toctext" href="quickstart.html">Quickstart</a></li><li><a class="toctext" href="arrays_colors.html">Arrays, Numbers, and Colors</a></li><li><a class="toctext" href="conversions_views.html">Conversions vs. views</a></li><li><a class="toctext" href="indexing.html">Arrays: more advanced indexing</a></li><li><a class="toctext" href="imageaxes.html">ImageAxes.jl</a></li><li><a class="toctext" href="imagefiltering.html">ImageFiltering.jl</a></li><li><a class="toctext" href="imagemetadata.html">ImageMetadata.jl</a></li><li><a class="toctext" href="troubleshooting.html">Installation troubleshooting</a></li><li class="current"><a class="toctext" href="function_reference.html">Summary and function reference</a><ul class="internal"><li><a class="toctext" href="#Image-loading-and-saving-1">Image loading and saving</a></li><li><a class="toctext" href="#Image-construction,-conversion,-and-views-1">Image construction, conversion, and views</a></li><li><a class="toctext" href="#Traits-1">Traits</a></li><li><a class="toctext" href="#Element-transformation-and-intensity-scaling-1">Element transformation and intensity scaling</a></li><li><a class="toctext" href="#Storage-type-transformation-1">Storage-type transformation</a></li><li><a class="toctext" href="#Color-conversion-1">Color conversion</a></li><li><a class="toctext" href="#Image-algorithms-1">Image algorithms</a></li><li><a class="toctext" href="#Image-metadata-utilities-1">Image metadata utilities</a></li></ul></li><li><a class="toctext" href="api_comparison.html">Comparison with other image processing frameworks</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="function_reference.html">Summary and function reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaImages/juliaimages.github.io/tree/1da621a059e5c6d1cc62dd64c95238b11d5bfa3f/docs/src/function_reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Summary-and-function-reference-1" href="#Summary-and-function-reference-1">Summary and function reference</a></h1><p>Below, <code>[]</code> in an argument list means an optional argument.</p><h2><a class="nav-anchor" id="Image-loading-and-saving-1" href="#Image-loading-and-saving-1">Image loading and saving</a></h2><pre><code class="language-julia">using FileIO
img = load(&quot;myimage.png&quot;)
save(&quot;imagecopy.jpg&quot;, img)</code></pre><p>Standard test images are available in the <a href="http://juliaimages.github.io/TestImages.jl">TestImages</a> package:</p><pre><code class="language-julia">using TestImages
img = testimage(&quot;mandrill&quot;)</code></pre><h2><a class="nav-anchor" id="Image-construction,-conversion,-and-views-1" href="#Image-construction,-conversion,-and-views-1">Image construction, conversion, and views</a></h2><p>Any array can be treated as an Image.  In graphical environments, only arrays with <a href="https://github.com/JuliaGraphics/ColorTypes.jl"><code>Colorant</code></a> element types (<code>Gray</code>, <code>RGB</code>, <code>ARGB</code>, etc.) are automatically displayed as images.</p><pre><code class="language-none">colorview
ColorView
channelview
ChannelView
normedview
rawview
permuteddimsview
StackedView
paddedviews</code></pre><p>Images with defined geometry and axis meaning can be constructed using the <a href="https://github.com/JuliaArrays/AxisArrays.jl"><code>AxisArrays</code></a> package:</p><pre><code class="language-julia">using AxisArrays
img = AxisArray(A, (:y, :x, :time), (0.25μm, 0.25μm, 0.125s))  # see Unitful.jl for units</code></pre><p>Custom metadata can be added as follows:</p><pre><code class="language-julia">img = ImageMeta(A, date=now(), patientID=12345)</code></pre><p>Any of these operations may be composed together, e.g., if you have an <code>m×n×3 UInt8</code> array, you can put it in canonical RGB format and add metadata:</p><pre><code class="language-julia">img = ImageMeta(colorview(RGB, normedview(permuteddimsview(A, (3,1,2)))), sample=&quot;control&quot;)</code></pre><h2><a class="nav-anchor" id="Traits-1" href="#Traits-1">Traits</a></h2><p>These functions are the preferred way to access certain types of &quot;internal&quot; data about an image. They can sometimes be useful in allowing you to write generic code.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.pixelspacing" href="#ImageCore.pixelspacing"><code>ImageCore.pixelspacing</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pixelspacing(img) -&gt; (sx, sy, ...)</code></pre><p>Return a tuple representing the separation between adjacent pixels along each axis of the image.  Defaults to (1,1,...).  Use ImagesAxes for images with anisotropic spacing or to encode the spacing using physical units.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L1-L8">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.spacedirections" href="#ImageCore.spacedirections"><code>ImageCore.spacedirections</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spacedirections(img) -&gt; (axis1, axis2, ...)</code></pre><p>Return a tuple-of-tuples, each <code>axis[i]</code> representing the displacement vector between adjacent pixels along spatial axis <code>i</code> of the image array, relative to some external coordinate system (&quot;physical coordinates&quot;).</p><p>By default this is computed from <code>pixelspacing</code>, but you can set this manually using ImagesMeta.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L18-L28">source</a><br/><div><pre><code class="language-none">spacedirections(img)</code></pre><p>Using ImageMetadata, you can set this property manually. For example, you could indicate that a photograph was taken with the camera tilted 30-degree relative to vertical using</p><pre><code class="language-none">img[&quot;spacedirections&quot;] = ((0.866025,-0.5),(0.5,0.866025))</code></pre><p>If not specified, it will be computed from <code>pixelspacing(img)</code>, placing the spacing along the &quot;diagonal&quot;.  If desired, you can set this property in terms of physical units, and each axis can have distinct units.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L247-L261">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.sdims" href="#ImageCore.sdims"><code>ImageCore.sdims</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sdims(img)</code></pre><p>Return the number of spatial dimensions in the image. Defaults to the same as <code>ndims</code>, but with ImagesAxes you can specify that some axes correspond to other quantities (e.g., time) and thus not included by <code>sdims</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L41-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.coords_spatial" href="#ImageCore.coords_spatial"><code>ImageCore.coords_spatial</code></a> — <span class="docstring-category">Function</span>.</div><div><p>coords_spatial(img)</p><p>Return a tuple listing the spatial dimensions of <code>img</code>.</p><p>Note that a better strategy may be to use ImagesAxes and take slices along the time axis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L51-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.size_spatial" href="#ImageCore.size_spatial"><code>ImageCore.size_spatial</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">size_spatial(img)</code></pre><p>Return a tuple listing the sizes of the spatial dimensions of the image. Defaults to the same as <code>size</code>, but using ImagesAxes you can mark some axes as being non-spatial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L81-L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.indices_spatial" href="#ImageCore.indices_spatial"><code>ImageCore.indices_spatial</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">indices_spatial(img)</code></pre><p>Return a tuple with the indices of the spatial dimensions of the image. Defaults to the same as <code>indices</code>, but using ImagesAxes you can mark some axes as being non-spatial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L96-L102">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.nimages" href="#ImageCore.nimages"><code>ImageCore.nimages</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nimages(img)</code></pre><p>Return the number of time-points in the image array. Defaults to</p><ol><li><p>Use ImagesAxes if you want to use an explicit time dimension.</p></li></ol></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L69-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.assert_timedim_last" href="#ImageCore.assert_timedim_last"><code>ImageCore.assert_timedim_last</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">assert_timedim_last(img)</code></pre><p>Throw an error if the image has a time dimension that is not the last dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/traits.jl#L113-L118">source</a><br/></section><h2><a class="nav-anchor" id="Element-transformation-and-intensity-scaling-1" href="#Element-transformation-and-intensity-scaling-1">Element transformation and intensity scaling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.clamp01" href="#ImageCore.clamp01"><code>ImageCore.clamp01</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clamp01(x) -&gt; y</code></pre><p>Produce a value <code>y</code> that lies between 0 and 1, and equal to <code>x</code> when <code>x</code> is already in this range. Equivalent to <code>clamp(x, 0, 1)</code> for numeric values. For colors, this function is applied to each color channel separately.</p><p>See also: <a href="function_reference.html#ImageCore.clamp01nan"><code>clamp01nan</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L3-L12">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.clamp01nan" href="#ImageCore.clamp01nan"><code>ImageCore.clamp01nan</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clamp01nan(x) -&gt; y</code></pre><p>Similar to <code>clamp01</code>, except that any <code>NaN</code> values are changed to 0.</p><p>See also: <a href="function_reference.html#ImageCore.clamp01"><code>clamp01</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L17-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.scaleminmax" href="#ImageCore.scaleminmax"><code>ImageCore.scaleminmax</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scaleminmax(min, max) -&gt; f
scaleminmax(T, min, max) -&gt; f</code></pre><p>Return a function <code>f</code> which maps values less than or equal to <code>min</code> to 0, values greater than or equal to <code>max</code> to 1, and uses a linear scale in between. <code>min</code> and <code>max</code> should be real values.</p><p>Optionally specify the return type <code>T</code>. If <code>T</code> is a colorant (e.g., RGB), then scaling is applied to each color channel.</p><p><strong>Examples</strong></p><p><strong>Example 1</strong></p><pre><code class="language-julia">julia&gt; f = scaleminmax(-10, 10)
(::#9) (generic function with 1 method)

julia&gt; f(10)
1.0

julia&gt; f(-10)
0.0

julia&gt; f(5)
0.75</code></pre><p><strong>Example 2</strong></p><pre><code class="language-julia">julia&gt; c = RGB(255.0,128.0,0.0)
RGB{Float64}(255.0,128.0,0.0)

julia&gt; f = scaleminmax(RGB, 0, 255)
(::#13) (generic function with 1 method)

julia&gt; f(c)
RGB{Float64}(1.0,0.5019607843137255,0.0)</code></pre><p>See also: <a href="function_reference.html#ImageCore.takemap"><code>takemap</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L28-L71">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.scalesigned" href="#ImageCore.scalesigned"><code>ImageCore.scalesigned</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scalesigned(maxabs) -&gt; f</code></pre><p>Return a function <code>f</code> which scales values in the range <code>[-maxabs, maxabs]</code> (clamping values that lie outside this range) to the range <code>[-1, 1]</code>.</p><p>See also: <a href="function_reference.html#ImageCore.colorsigned"><code>colorsigned</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L127-L135">source</a><br/><div><pre><code class="language-none">scalesigned(min, center, max) -&gt; f</code></pre><p>Return a function <code>f</code> which scales values in the range <code>[min, center]</code> to <code>[-1,0]</code> and <code>[center,max]</code> to <code>[0,1]</code>. Values smaller than <code>min</code>/<code>max</code> get clamped to <code>min</code>/<code>max</code>, respectively.</p><p>See also: <a href="function_reference.html#ImageCore.colorsigned"><code>colorsigned</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L141-L149">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.colorsigned" href="#ImageCore.colorsigned"><code>ImageCore.colorsigned</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">colorsigned()
colorsigned(colorneg, colorpos) -&gt; f
colorsigned(colorneg, colorcenter, colorpos) -&gt; f</code></pre><p>Define a function that maps negative values (in the range [-1,0]) to the linear colormap between <code>colorneg</code> and <code>colorcenter</code>, and positive values (in the range [0,1]) to the linear colormap between <code>colorcenter</code> and <code>colorpos</code>.</p><p>The default colors are:</p><ul><li><p><code>colorcenter</code>: white</p></li><li><p><code>colorneg</code>: green1</p></li><li><p><code>colorpos</code>: magenta</p></li></ul><p>See also: <a href="function_reference.html#ImageCore.scalesigned"><code>scalesigned</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L165-L182">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.takemap" href="#ImageCore.takemap"><code>ImageCore.takemap</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">takemap(f, A) -&gt; fnew
takemap(f, T, A) -&gt; fnew</code></pre><p>Given a value-mapping function <code>f</code> and an array <code>A</code>, return a &quot;concrete&quot; mapping function <code>fnew</code>. When applied to elements of <code>A</code>, <code>fnew</code> should return valid values for storage or display, for example in the range from 0 to 1 (for grayscale) or valid colorants. <code>fnew</code> may be adapted to the actual values present in <code>A</code>, and may not produce valid values for any inputs not in <code>A</code>.</p><p>Optionally one can specify the output type <code>T</code> that <code>fnew</code> should produce.</p><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; A = [0, 1, 1000];

julia&gt; f = takemap(scaleminmax, A)
(::#7) (generic function with 1 method)

julia&gt; f.(A)
3-element Array{Float64,1}:
 0.0
 0.001
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/map.jl#L197-L223">source</a><br/></section><h2><a class="nav-anchor" id="Storage-type-transformation-1" href="#Storage-type-transformation-1">Storage-type transformation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.float32" href="#ImageCore.float32"><code>ImageCore.float32</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">float32.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>Float32</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.float64" href="#ImageCore.float64"><code>ImageCore.float64</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">float64.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>Float64</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.n0f8" href="#ImageCore.n0f8"><code>ImageCore.n0f8</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n0f8.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>N0f8</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.n6f10" href="#ImageCore.n6f10"><code>ImageCore.n6f10</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n6f10.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>N6f10</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.n4f12" href="#ImageCore.n4f12"><code>ImageCore.n4f12</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n4f12.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>N4f12</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.n2f14" href="#ImageCore.n2f14"><code>ImageCore.n2f14</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n2f14.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>N2f14</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.n0f16" href="#ImageCore.n0f16"><code>ImageCore.n0f16</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">n0f16.(img)</code></pre><p>converts the raw storage type of <code>img</code> to <code>N0f16</code>, without changing the color space.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageCore.jl/tree/23ed55e46631980e98f9301e5658646f0c184876/src/convert_reinterpret.jl#L117-L121">source</a><br/></section><h2><a class="nav-anchor" id="Color-conversion-1" href="#Color-conversion-1">Color conversion</a></h2><pre><code class="language-julia">imgg = Gray.(img)</code></pre><p>calculates a grayscale representation of a color image using the <a href="http://en.wikipedia.org/wiki/Luma_%28video%29#Rec._601_luma_versus_Rec._709_luma_coefficients">Rec 601 luma</a>.</p><pre><code class="language-julia">imghsv = HSV.(img)</code></pre><p>converts to an HSV representation of color information.</p><h2><a class="nav-anchor" id="Image-algorithms-1" href="#Image-algorithms-1">Image algorithms</a></h2><h3><a class="nav-anchor" id="Linear-filtering-1" href="#Linear-filtering-1">Linear filtering</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imfilter" href="#ImageFiltering.imfilter"><code>ImageFiltering.imfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imfilter([T], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter([r], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter(r, T, img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt</code></pre><p>Filter an array <code>img</code> with kernel <code>kernel</code> by computing their correlation.</p><p><code>kernel[0,0,..]</code> corresponds to the origin (zero displacement) of the kernel; you can use <code>centered</code> to place the origin at the array center, or use the OffsetArrays package to set <code>kernel</code>&#39;s indices manually. For example, to filter with a random <em>centered</em> 3x3 kernel, you could use either of the following:</p><pre><code class="language-none">kernel = centered(rand(3,3))
kernel = OffsetArray(rand(3,3), -1:1, -1:1)</code></pre><p><code>kernel</code> can be specified as an array or as a &quot;factored kernel,&quot; a tuple <code>(filt1, filt2, ...)</code> of filters to apply along each axis of the image. In cases where you know your kernel is separable, this format can speed processing.  Each of these should have the same dimensionality as the image itself, and be shaped in a manner that indicates the filtering axis, e.g., a 3x1 filter for filtering the first dimension and a 1x3 filter for filtering the second dimension. In two dimensions, any kernel passed as a single matrix is checked for separability; if you want to eliminate that check, pass the kernel as a single-element tuple, <code>(kernel,)</code>.</p><p>Optionally specify the <code>border</code>, as one of <code>Fill(value)</code>, <code>&quot;replicate&quot;</code>, <code>&quot;circular&quot;</code>, <code>&quot;symmetric&quot;</code>, <code>&quot;reflect&quot;</code>, <code>NA()</code>, or <code>Inner()</code>. The default is <code>&quot;replicate&quot;</code>. These choices specify the boundary conditions, and therefore affect the result at the edges of the image. See <code>padarray</code> for more information.</p><p><code>alg</code> allows you to choose the particular algorithm: <code>FIR()</code> (finite impulse response, aka traditional digital filtering) or <code>FFT()</code> (Fourier-based filtering). If no choice is specified, one will be chosen based on the size of the image and kernel in a way that strives to deliver good performance. Alternatively you can use a custom filter type, like <code>KernelFactors.IIRGaussian</code>.</p><p>Optionally, you can control the element type of the output image by passing in a type <code>T</code> as the first argument.</p><p>You can also dispatch to different implementations by passing in a resource <code>r</code> as defined by the ComputationalResources package.  For example,</p><pre><code class="language-none">imfilter(ArrayFire(), img, kernel)</code></pre><p>would request that the computation be performed on the GPU using the ArrayFire libraries.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter!"><code>imfilter!</code></a>, <a href="function_reference.html#ImageFiltering.centered"><code>centered</code></a>, <a href="function_reference.html#ImageFiltering.padarray"><code>padarray</code></a>, <a href="function_reference.html#ImageFiltering.Pad"><code>Pad</code></a>, <a href="function_reference.html#ImageFiltering.Fill"><code>Fill</code></a>, <a href="function_reference.html#ImageFiltering.Inner"><code>Inner</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/imfilter.jl#L50-L104">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imfilter!" href="#ImageFiltering.imfilter!"><code>ImageFiltering.imfilter!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imfilter!(imgfilt, img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter!(r, imgfilt, img, kernel, border, [inds])
imfilter!(r, imgfilt, img, kernel, border::NoPad, [inds=indices(imgfilt)])</code></pre><p>Filter an array <code>img</code> with kernel <code>kernel</code> by computing their correlation, storing the result in <code>imgfilt</code>.</p><p>The indices of <code>imgfilt</code> determine the region over which the filtered image is computed–-you can use this fact to select just a specific region of interest, although be aware that the input <code>img</code> might still get padded.  Alteratively, explicitly provide the indices <code>inds</code> of <code>imgfilt</code> that you want to calculate, and use <code>NoPad</code> boundary conditions. In such cases, you are responsible for supplying appropriate padding: <code>img</code> must be indexable for all of the locations needed for calculating the output. This syntax is best-supported for FIR filtering; in particular, that that IIR filtering can lead to results that are inconsistent with respect to filtering the entire array.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/imfilter.jl#L164-L185">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imgradients" href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imgradients(img, kernelfun=KernelFactors.ando3, border=&quot;replicate&quot;) -&gt; gimg1, gimg2, ...</code></pre><p>Estimate the gradient of <code>img</code> at all points of the image, using a kernel specified by <code>kernelfun</code>. The gradient is returned as a tuple-of-arrays, one for each dimension of the input; <code>gimg1</code> corresponds to the derivative with respect to the first dimension, <code>gimg2</code> to the second, and so on. At the image edges, <code>border</code> is used to specify the boundary conditions.</p><p><code>kernelfun</code> may be one of the filters defined in the <code>KernelFactors</code> module, or more generally any function which satisfies the following interface:</p><pre><code class="language-none">kernelfun(extended::NTuple{N,Bool}, d) -&gt; kern_d</code></pre><p><code>kern_d</code> is the kernel for producing the derivative with respect to the <code>d</code>th dimension of an <code>N</code>-dimensional array. <code>extended[i]</code> is true if the image is of size &gt; 1 along dimension <code>i</code>. <code>kern_d</code> may be provided as a dense or factored kernel, with factored representations recommended when the kernel is separable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/specialty.jl#L19-L40">source</a><br/><div><pre><code class="language-none">imgradients(img, points, [kernelfunc], [border]) -&gt; G</code></pre><p>Performs edge detection filtering in the N-dimensional array <code>img</code>. Gradients are computed at specified <code>points</code> (or indexes) in the array.</p><p>All kernel functions are specified as <code>KernelFactors.func</code>. For 2d images, the choices for <code>func</code> include <code>sobel</code>, <code>prewitt</code>, <code>ando3</code>, <code>ando4</code>, and <code>ando5</code>. For other dimensionalities, the <code>ando4</code> and <code>ando5</code> kernels are not available.</p><p>Border options:<code>&quot;replicate&quot;</code>, <code>&quot;circular&quot;</code>, <code>&quot;reflect&quot;</code>, <code>&quot;symmetric&quot;</code>.</p><p>Returns a 2D array <code>G</code> with the gradients as rows. The number of rows is the number of points at which the gradient was computed and the number of columns is the dimensionality of the array.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/specialty.jl#L66-L83">source</a><br/></section><h4><a class="nav-anchor" id="Kernel-1" href="#Kernel-1">Kernel</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.sobel" href="#ImageFiltering.Kernel.sobel"><code>ImageFiltering.Kernel.sobel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = sobel()</code></pre><p>Return kernels for two-dimensional gradient compution using the Sobel operator. <code>diff1</code> computes the gradient along the first (y) dimension, and <code>diff2</code> computes the gradient along the second (x) dimension.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.sobel"><code>KernelFactors.sobel</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L12-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.prewitt" href="#ImageFiltering.Kernel.prewitt"><code>ImageFiltering.Kernel.prewitt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = prewitt()</code></pre><p>Return kernels for two-dimensional gradient compution using the Prewitt operator.  <code>diff1</code> computes the gradient along the first (y) dimension, and <code>diff2</code> computes the gradient along the second (x) dimension.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.prewitt"><code>KernelFactors.prewitt</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.sobel"><code>Kernel.sobel</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L25-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando3" href="#ImageFiltering.Kernel.ando3"><code>ImageFiltering.Kernel.ando3</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando3()</code></pre><p>Return 3x3 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando3"><code>KernelFactors.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L39-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando4" href="#ImageFiltering.Kernel.ando4"><code>ImageFiltering.Kernel.ando4</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando4()</code></pre><p>Return 4x4 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L57-L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando5" href="#ImageFiltering.Kernel.ando5"><code>ImageFiltering.Kernel.ando5</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando5()</code></pre><p>Return 5x5 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L84-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.gaussian" href="#ImageFiltering.Kernel.gaussian"><code>ImageFiltering.Kernel.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gaussian((σ1, σ2, ...), [(l1, l2, ...]) -&gt; g
gaussian(σ)                  -&gt; g</code></pre><p>Construct a multidimensional gaussian filter, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p><p>If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is constructed.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.gaussian"><code>KernelFactors.gaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L112-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.DoG" href="#ImageFiltering.Kernel.DoG"><code>ImageFiltering.Kernel.DoG</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DoG((σp1, σp2, ...), (σm1, σm2, ...), [l1, l2, ...]) -&gt; k
DoG((σ1, σ2, ...))                                   -&gt; k
DoG(σ::Real)                                         -&gt; k</code></pre><p>Construct a multidimensional difference-of-gaussian kernel <code>k</code>, equal to <code>gaussian(σp, l)-gaussian(σm, l)</code>.  When only a single <code>σ</code> is supplied, the default is to choose <code>σp = σ, σm = √2 σ</code>. Optionally provide the kernel length <code>l</code>; the default is to extend by two <code>max(σp,σm)</code> in each direction from the center. <code>l</code> must be odd.</p><p>If <code>σ</code> is provided as a single number, a symmetric 2d DoG kernel is returned.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L139-L154">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.LoG" href="#ImageFiltering.Kernel.LoG"><code>ImageFiltering.Kernel.LoG</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LoG((σ1, σ2, ...)) -&gt; k
LoG(σ)             -&gt; k</code></pre><p>Construct a Laplacian-of-Gaussian kernel <code>k</code>. <code>σd</code> is the gaussian width along dimension <code>d</code>.  If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is returned.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a> and <a href="function_reference.html#ImageFiltering.Kernel.Laplacian"><code>Kernel.Laplacian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L165-L174">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.Laplacian" href="#ImageFiltering.Kernel.Laplacian"><code>ImageFiltering.Kernel.Laplacian</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Laplacian((true,true,false,...))
Laplacian(dims, N)
Lacplacian()</code></pre><p>Laplacian kernel in <code>N</code> dimensions, taking derivatives along the directions marked as <code>true</code> in the supplied tuple. Alternatively, one can pass <code>dims</code>, a listing of the dimensions for differentiation. (However, this variant is not inferrable.)</p><p><code>Laplacian()</code> is the 2d laplacian, equivalent to <code>Laplacian((true,true))</code>.</p><p>The kernel is represented as an opaque type, but you can use <code>convert(AbstractArray, L)</code> to convert it into array format.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L207-L221">source</a><br/></section><h4><a class="nav-anchor" id="KernelFactors-1" href="#KernelFactors-1">KernelFactors</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.sobel" href="#ImageFiltering.KernelFactors.sobel"><code>ImageFiltering.KernelFactors.sobel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kern1, kern2 = sobel()</code></pre><p>Factored Sobel filters for dimensions 1 and 2 of a two-dimensional image. Each is a 2-tuple of one-dimensional filters.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L145-L150">source</a><br/><div><pre><code class="language-none">kern = sobel(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Sobel filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L157-L162">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.prewitt" href="#ImageFiltering.KernelFactors.prewitt"><code>ImageFiltering.KernelFactors.prewitt</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = prewitt()</code> returns factored Prewitt filters for dimensions 1 and 2 of your image</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L167">source</a><br/><div><pre><code class="language-none">kern = prewitt(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Prewitt filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L174-L179">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando3" href="#ImageFiltering.KernelFactors.ando3"><code>ImageFiltering.KernelFactors.ando3</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando3()</code> returns optimal 3x3 gradient filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L193-L198">source</a><br/><div><pre><code class="language-none">kern = ando3(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 3) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L205-L211">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando4" href="#ImageFiltering.KernelFactors.ando4"><code>ImageFiltering.KernelFactors.ando4</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando4()</code> returns separable approximations of the optimal 4x4 filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando4</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L216-L223">source</a><br/><div><pre><code class="language-none">kern = ando4(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 4) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L230-L236">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando5" href="#ImageFiltering.KernelFactors.ando5"><code>ImageFiltering.KernelFactors.ando5</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando5_sep()</code> returns separable approximations of the optimal 5x5 gradient filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L245-L252">source</a><br/><div><pre><code class="language-none">kern = ando5(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 5) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L259-L265">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.gaussian" href="#ImageFiltering.KernelFactors.gaussian"><code>ImageFiltering.KernelFactors.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gaussian(σ::Real, [l]) -&gt; g</code></pre><p>Construct a 1d gaussian kernel <code>g</code> with standard deviation <code>σ</code>, optionally providing the kernel length <code>l</code>. The default is to extend by two <code>σ</code> in each direction from the center. <code>l</code> must be odd.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L276-L282">source</a><br/><div><pre><code class="language-none">gaussian((σ1, σ2, ...), [l]) -&gt; (g1, g2, ...)</code></pre><p>Construct a multidimensional gaussian filter as a product of single-dimension factors, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L290-L297">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.IIRGaussian" href="#ImageFiltering.KernelFactors.IIRGaussian"><code>ImageFiltering.KernelFactors.IIRGaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">IIRGaussian([T], σ; emit_warning::Bool=true)</code></pre><p>Construct an infinite impulse response (IIR) approximation to a Gaussian of standard deviation <code>σ</code>. <code>σ</code> may either be a single real number or a tuple of numbers; in the latter case, a tuple of such filters will be created, each for filtering a different dimension of an array.</p><p>Optionally specify the type <code>T</code> for the filter coefficients; if not supplied, it will match <code>σ</code> (unless <code>σ</code> is not floating-point, in which case <code>Float64</code> will be chosen).</p><p><strong>Citation</strong></p><p>I. T. Young, L. J. van Vliet, and M. van Ginkel, &quot;Recursive Gabor Filtering&quot;. IEEE Trans. Sig. Proc., 50: 2798-2805 (2002).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L360-L376">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.TriggsSdika" href="#ImageFiltering.KernelFactors.TriggsSdika"><code>ImageFiltering.KernelFactors.TriggsSdika</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TriggsSdika(a, b, scale, M)</code></pre><p>Defines a kernel for one-dimensional infinite impulse response (IIR) filtering. <code>a</code> is a &quot;forward&quot; filter, <code>b</code> a &quot;backward&quot; filter, <code>M</code> is a matrix for matching boundary conditions at the right edge, and <code>scale</code> is a constant scaling applied to each element at the conclusion of filtering.</p><p><strong>Citation</strong></p><p>B. Triggs and M. Sdika, &quot;Boundary conditions for Young-van Vliet recursive filtering&quot;. IEEE Trans. on Sig. Proc. 54: 2365-2367 (2006).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L318-L332">source</a><br/><div><pre><code class="language-none">TriggsSdika(ab, scale)</code></pre><p>Create a symmetric Triggs-Sdika filter (with <code>a = b = ab</code>). <code>M</code> is calculated for you. Only length 3 filters are currently supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L335-L340">source</a><br/></section><h4><a class="nav-anchor" id="Kernel-utilities-1" href="#Kernel-utilities-1">Kernel utilities</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.centered" href="#ImageFiltering.centered"><code>ImageFiltering.centered</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">centered(kernel) -&gt; shiftedkernel</code></pre><p>Shift the origin-of-coordinates to the center of <code>kernel</code>. The center-element of <code>kernel</code> will be accessed by <code>shiftedkernel[0, 0, ...]</code>.</p><p>This function makes it easy to supply kernels using regular Arrays, and provides compatibility with other languages that do not support arbitrary indices.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/utils.jl#L1-L13">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.kernelfactors" href="#ImageFiltering.KernelFactors.kernelfactors"><code>ImageFiltering.KernelFactors.kernelfactors</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kernelfactors(factors::Tuple)</code></pre><p>Prepare a factored kernel for filtering. If passed a 2-tuple of vectors of lengths <code>m</code> and <code>n</code>, this will return a 2-tuple of <code>ReshapedVector</code>s that are effectively of sizes <code>m×1</code> and <code>1×n</code>. In general, each successive <code>factor</code> will be reshaped to extend along the corresponding dimension.</p><p>If passed a tuple of general arrays, it is assumed that each is shaped appropriately along its &quot;leading&quot; dimensions; the dimensionality of each is &quot;extended&quot; to <code>N = length(factors)</code>, appending 1s to the size as needed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L417-L429">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.reflect" href="#ImageFiltering.Kernel.reflect"><code>ImageFiltering.Kernel.reflect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reflect(kernel) --&gt; reflectedkernel</code></pre><p>Compute the pointwise reflection around 0, 0, ... of the kernel <code>kernel</code>.  Using <code>imfilter</code> with a <code>reflectedkernel</code> performs convolution, rather than correlation, with respect to the original <code>kernel</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernel.jl#L243-L249">source</a><br/></section><h4><a class="nav-anchor" id="Boundaries-and-padding-1" href="#Boundaries-and-padding-1">Boundaries and padding</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.padarray" href="#ImageFiltering.padarray"><code>ImageFiltering.padarray</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">padarray([T], img, border) --&gt; imgpadded</code></pre><p>Generate a padded image from an array <code>img</code> and a specification <code>border</code> of the boundary conditions and amount of padding to add. <code>border</code> can be a <code>Pad</code>, <code>Fill</code>, or <code>Inner</code> object.</p><p>Optionally provide the element type <code>T</code> of <code>imgpadded</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L137-L145">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Pad" href="#ImageFiltering.Pad"><code>ImageFiltering.Pad</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Pad</code> is a type that stores choices about padding. Instances must set <code>style</code>, a Symbol specifying the boundary conditions of the image, one of:</p><ul><li><p><code>:replicate</code> (repeat edge values to infinity)</p></li><li><p><code>:circular</code> (image edges &quot;wrap around&quot;)</p></li><li><p><code>:symmetric</code> (the image reflects relative to a position between pixels)</p></li><li><p><code>:reflect</code> (the image reflects relative to the edge itself)</p></li></ul><p>The default value is <code>:replicate</code>.</p><p>It&#39;s worth emphasizing that padding is most straightforwardly specified as a string,</p><pre><code class="language-none">imfilter(img, kernel, &quot;replicate&quot;)</code></pre><p>rather than</p><pre><code class="language-none">imfilter(img, kernel, Pad(:replicate))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L31-L49">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Fill" href="#ImageFiltering.Fill"><code>ImageFiltering.Fill</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Fill(val)
Fill(val, lo, hi)</code></pre><p>Pad the edges of the image with a constant value, <code>val</code>.</p><p>Optionally supply the extent of the padding, see <code>Pad</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">imfilter(img, kernel, Fill(zero(eltype(img))))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L238-L249">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Inner" href="#ImageFiltering.Inner"><code>ImageFiltering.Inner</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Inner()
Inner(lo, hi)</code></pre><p>Indicate that edges are to be discarded in filtering, only the interior of the result it to be returned.</p><p><strong>Example:</strong></p><pre><code class="language-none">imfilter(img, kernel, Inner())</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L181-L190">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.NA" href="#ImageFiltering.NA"><code>ImageFiltering.NA</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NA()
NA(lo, hi)</code></pre><p>Choose filtering using &quot;NA&quot; (Not Available) boundary conditions. This is most appropriate for filters that have only positive weights, such as blurring filters. Effectively, the output pixel value is normalized in the following way:</p><pre><code class="language-none">          filtered img with Fill(0) boundary conditions
output =  ---------------------------------------------
          filtered 1   with Fill(0) boundary conditions</code></pre><p>As a consequence, filtering has the same behavior as <code>nanmean</code>. Indeed, invalid pixels in <code>img</code> can be marked as <code>NaN</code> and then they are effectively omitted from the filtered result.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L196-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.NoPad" href="#ImageFiltering.NoPad"><code>ImageFiltering.NoPad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NoPad()
NoPad(border)</code></pre><p>Indicates that no padding should be applied to the input array, or that you have already pre-padded the input image. Passing a <code>border</code> object allows you to preserve &quot;memory&quot; of a border choice; it can be retrieved by indexing with <code>[]</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">np = NoPad(Pad(:replicate))
imfilter!(out, img, kernel, np)</code></pre><p>runs filtering directly, skipping any padding steps.  Every entry of <code>out</code> must be computable using in-bounds operations on <code>img</code> and <code>kernel</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/border.jl#L12-L26">source</a><br/></section><h4><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.FIR" href="#ImageFiltering.Algorithm.FIR"><code>ImageFiltering.Algorithm.FIR</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter using a direct algorithm</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/ImageFiltering.jl#L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.FFT" href="#ImageFiltering.Algorithm.FFT"><code>ImageFiltering.Algorithm.FFT</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter using the Fast Fourier Transform</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/ImageFiltering.jl#L27">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.IIR" href="#ImageFiltering.Algorithm.IIR"><code>ImageFiltering.Algorithm.IIR</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter with an Infinite Impulse Response filter</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/ImageFiltering.jl#L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.Mixed" href="#ImageFiltering.Algorithm.Mixed"><code>ImageFiltering.Algorithm.Mixed</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter with a cascade of mixed types (IIR, FIR)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/ImageFiltering.jl#L33">source</a><br/></section><h4><a class="nav-anchor" id="Internal-machinery-1" href="#Internal-machinery-1">Internal machinery</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ReshapedOneD" href="#ImageFiltering.KernelFactors.ReshapedOneD"><code>ImageFiltering.KernelFactors.ReshapedOneD</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ReshapedOneD{N,Npre}(data)</code></pre><p>Return an object of dimensionality <code>N</code>, where <code>data</code> must have dimensionality 1. The indices are <code>0:0</code> for the first <code>Npre</code> dimensions, have the indices of <code>data</code> for dimension <code>Npre+1</code>, and are <code>0:0</code> for the remaining dimensions.</p><p><code>data</code> must support <code>eltype</code> and <code>ndims</code>, but does not have to be an AbstractArray.</p><p>ReshapedOneDs allow one to specify a &quot;filtering dimension&quot; for a 1-dimensional filter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/kernelfactors.jl#L14-L27">source</a><br/></section><h3><a class="nav-anchor" id="Nonlinear-filtering-and-transformation-1" href="#Nonlinear-filtering-and-transformation-1">Nonlinear filtering and transformation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.MapWindow.mapwindow" href="#ImageFiltering.MapWindow.mapwindow"><code>ImageFiltering.MapWindow.mapwindow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapwindow(f, img, window, [border=&quot;replicate&quot;]) -&gt; imgf</code></pre><p>Apply <code>f</code> to sliding windows of <code>img</code>, with window size or indices specified by <code>window</code>. For example, <code>mapwindow(median!, img, window)</code> returns an <code>Array</code> of values similar to <code>img</code> (median-filtered, of course), whereas <code>mapwindow(extrema, img, window)</code> returns an <code>Array</code> of <code>(min,max)</code> tuples over a window of size <code>window</code> centered on each point of <code>img</code>.</p><p>The function <code>f</code> receives a buffer <code>buf</code> for the window of data surrounding the current point. If <code>window</code> is specified as a Dims-tuple (tuple-of-integers), then all the integers must be odd and the window is centered around the current image point. For example, if <code>window=(3,3)</code>, then <code>f</code> will receive an Array <code>buf</code> corresponding to offsets <code>(-1:1, -1:1)</code> from the <code>imgf[i,j]</code> for which this is currently being computed. Alternatively, <code>window</code> can be a tuple of AbstractUnitRanges, in which case the specified ranges are used for <code>buf</code>; this allows you to use asymmetric windows if needed.</p><p><code>border</code> specifies how the edges of <code>img</code> should be handled; see <code>imfilter</code> for details.</p><p>For functions that can only take <code>AbstractVector</code> inputs, you might have to first specialize <code>default_shape</code>:</p><pre><code class="language-julia">f = v-&gt;quantile(v, 0.75)
ImageFiltering.MapWindow.default_shape(::typeof(f)) = vec</code></pre><p>and then <code>mapwindow(f, img, (m,n))</code> should filter at the 75th quantile.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/fbc621cabc48ef608ef26f77dc7cd8b2ea16e092/src/mapwindow.jl#L9-L43">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.imROF" href="#Images.imROF"><code>Images.imROF</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imgr = imROF(img, lambda, iterations)</code></pre><p>Perform Rudin-Osher-Fatemi (ROF) filtering, more commonly known as Total Variation (TV) denoising or TV regularization. <code>lambda</code> is the regularization coefficient for the derivative, and <code>iterations</code> is the number of relaxation iterations taken. 2d only.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L556-L565">source</a><br/></section><h3><a class="nav-anchor" id="Edge-detection-1" href="#Edge-detection-1">Edge detection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.magnitude" href="#Images.magnitude"><code>Images.magnitude</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">m = magnitude(grad_x, grad_y)</code></pre><p>Calculates the magnitude of the gradient images given by <code>grad_x</code> and <code>grad_y</code>. Equivalent to <span>$sqrt(grad_x.^2 + grad_y.^2)$</span>.</p><p>Returns a magnitude image the same size as <code>grad_x</code> and <code>grad_y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L48-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.phase" href="#Images.phase"><code>Images.phase</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">phase(grad_x, grad_y) -&gt; p</code></pre><p>Calculate the rotation angle of the gradient given by <code>grad_x</code> and <code>grad_y</code>. Equivalent to <code>atan2(-grad_y, grad_x)</code>, except that when both <code>grad_x</code> and <code>grad_y</code> are effectively zero, the corresponding angle is set to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L4-L10">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.orientation" href="#Images.orientation"><code>Images.orientation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orientation(grad_x, grad_y) -&gt; orient</code></pre><p>Calculate the orientation angle of the strongest edge from gradient images given by <code>grad_x</code> and <code>grad_y</code>.  Equivalent to <code>atan2(grad_x, grad_y)</code>.  When both <code>grad_x</code> and <code>grad_y</code> are effectively zero, the corresponding angle is set to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L31-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.magnitude_phase" href="#Images.magnitude_phase"><code>Images.magnitude_phase</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">magnitude_phase(grad_x, grad_y) -&gt; m, p</code></pre><p>Convenience function for calculating the magnitude and phase of the gradient images given in <code>grad_x</code> and <code>grad_y</code>.  Returns a tuple containing the magnitude and phase images.  See <code>magnitude</code> and <code>phase</code> for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L71-L77">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.imedge" href="#Images.imedge"><code>Images.imedge</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">grad_x, grad_y, mag, orient = imedge(img, [method], [border])</code></pre><p>Edge-detection filtering. <code>method</code> is one of <code>&quot;sobel&quot;</code>, <code>&quot;prewitt&quot;</code>, <code>&quot;ando3&quot;</code>, <code>&quot;ando4&quot;</code>, <code>&quot;ando4_sep&quot;</code>, <code>&quot;ando5&quot;</code>, or <code>&quot;ando5_sep&quot;</code>, defaulting to <code>&quot;ando3&quot;</code> (see the functions of the same name for more information).  <code>border</code> is any of the boundary conditions specified in <code>padarray</code>.</p><p>Returns a tuple <code>(grad_x, grad_y, mag, orient)</code>, which are the horizontal gradient, vertical gradient, and the magnitude and orientation of the strongest edge, respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L94-L107">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.thin_edges" href="#Images.thin_edges"><code>Images.thin_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">thinned = thin_edges(img, gradientangle, [border])
thinned, subpix = thin_edges_subpix(img, gradientangle, [border])
thinned, subpix = thin_edges_nonmaxsup(img, gradientangle, [border]; [radius::Float64=1.35], [theta=pi/180])
thinned, subpix = thin_edges_nonmaxsup_subpix(img, gradientangle, [border]; [radius::Float64=1.35], [theta=pi/180])</code></pre><p>Edge thinning for 2D edge images.  Currently the only algorithm available is non-maximal suppression, which takes an edge image and its gradient angle, and checks each edge point for local maximality in the direction of the gradient. The returned image is non-zero only at maximal edge locations.</p><p><code>border</code> is any of the boundary conditions specified in <code>padarray</code>.</p><p>In addition to the maximal edge image, the <code>_subpix</code> versions of these functions also return an estimate of the subpixel location of each local maxima, as a 2D array or image of <code>Graphics.Point</code> objects.  Additionally, each local maxima is adjusted to the estimated value at the subpixel location.</p><p>Currently, the <code>_nonmaxsup</code> functions are identical to the first two function calls, except that they also accept additional keyword arguments.  <code>radius</code> indicates the step size to use when searching in the direction of the gradient; values between 1.2 and 1.5 are suggested (default 1.35).  <code>theta</code> indicates the step size to use when discretizing angles in the <code>gradientangle</code> image, in radians (default: 1 degree in radians = pi/180).</p><p>Example:</p><pre><code class="language-none">g = rgb2gray(rgb_image)
gx, gy = imgradients(g)
mag, grad_angle = magnitude_phase(gx,gy)
mag[mag .&lt; 0.5] = 0.0  # Threshold magnitude image
thinned, subpix =  thin_edges_subpix(mag, grad_angle)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L116-L152">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.canny" href="#Images.canny"><code>Images.canny</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canny_edges = canny(img, sigma = 1.4, upperThreshold = 0.80, lowerThreshold = 0.20)</code></pre><p>Performs Canny Edge Detection on the input image.</p><p>Parameters :</p><p>sigma :           Specifies the standard deviation of the gaussian filter   upperThreshold :  Upper bound for hysteresis thresholding   lowerThreshold :  Lower bound for hysteresis thresholding   astype :          Specifies return type of result   percentile :      Specifies if upperThreshold and lowerThreshold should be used                     as quantiles or absolute values</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/edge.jl#L378-L394">source</a><br/></section><h3><a class="nav-anchor" id="Corner-Detection-1" href="#Corner-Detection-1">Corner Detection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.imcorner" href="#Images.imcorner"><code>Images.imcorner</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">corners = imcorner(img; [method])
corners = imcorner(img, threshold, percentile; [method])</code></pre><p>Performs corner detection using one of the following methods -</p><pre><code class="language-none">1. harris
2. shi_tomasi
3. kitchen_rosenfeld</code></pre><p>The parameters of the individual methods are described in their documentation. The maxima values of the resultant responses are taken as corners. If a threshold is specified, the values of the responses are thresholded to give the corner pixels. The threshold is assumed to be a percentile value unless <code>percentile</code> is set to false.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/corner.jl#L1-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.harris" href="#Images.harris"><code>Images.harris</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">harris_response = harris(img; [k], [border], [weights])</code></pre><p>Performs Harris corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/corner.jl#L37-L44">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.shi_tomasi" href="#Images.shi_tomasi"><code>Images.shi_tomasi</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">shi_tomasi_response = shi_tomasi(img; [border], [weights])</code></pre><p>Performs Shi Tomasi corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/corner.jl#L51-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.kitchen_rosenfeld" href="#Images.kitchen_rosenfeld"><code>Images.kitchen_rosenfeld</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kitchen_rosenfeld_response = kitchen_rosenfeld(img; [border])</code></pre><p>Performs Kitchen Rosenfeld corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/corner.jl#L65-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.fastcorners" href="#Images.fastcorners"><code>Images.fastcorners</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fastcorners(img, n, threshold) -&gt; corners</code></pre><p>Performs FAST Corner Detection. <code>n</code> is the number of contiguous pixels which need to be greater (lesser) than intensity + threshold (intensity - threshold) for a pixel to be marked as a corner. The default value for n is 12.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/corner.jl#L102-L108">source</a><br/></section><h3><a class="nav-anchor" id="Feature-Extraction-1" href="#Feature-Extraction-1">Feature Extraction</a></h3><p>See the <a href>ImageFeatures</a> package for a much more comprehensive set of tools.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.blob_LoG" href="#Images.blob_LoG"><code>Images.blob_LoG</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">blob_LoG(img, σs, [edges]) -&gt; Vector{BlobLoG}</code></pre><p>Find &quot;blobs&quot; in an N-D image using the negative Lapacian of Gaussians with the specifed vector or tuple of σ values. The algorithm searches for places where the filtered image (for a particular σ) is at a peak compared to all spatially- and σ-adjacent voxels.</p><p>The optional <code>edges</code> argument controls whether peaks on the edges are included. <code>edges</code> can be <code>true</code> or <code>false</code>, or a N+1-tuple in which the first entry controls whether edge-σ values are eligible to serve as peaks, and the remaining N entries control each of the N dimensions of <code>img</code>.</p><p><strong>Citation:</strong></p><p>Lindeberg T (1998), &quot;Feature Detection with Automatic Scale Selection&quot;, International Journal of Computer Vision, 30(2), 79–116.</p><p>See also: <a href="function_reference.html#Images.BlobLoG"><code>BlobLoG</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L404-L424">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.BlobLoG" href="#Images.BlobLoG"><code>Images.BlobLoG</code></a> — <span class="docstring-category">Type</span>.</div><div><p>BlobLoG stores information about the location of peaks as discovered by <code>blob_LoG</code>. It has fields:</p><ul><li><p>location: the location of a peak in the filtered image (a CartesianIndex)</p></li><li><p>σ: the value of σ which lead to the largest <code>-LoG</code>-filtered amplitude at this location</p></li><li><p>amplitude: the value of the <code>-LoG(σ)</code>-filtered image at the peak</p></li></ul><p>Note that the radius is equal to σ√2.</p><p>See also: <a href="function_reference.html#Images.blob_LoG"><code>blob_LoG</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L386-L397">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.findlocalmaxima" href="#Images.findlocalmaxima"><code>Images.findlocalmaxima</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>findlocalmaxima(img, [region, edges]) -&gt; Vector{Tuple}</code></p><p>Returns the coordinates of elements whose value is larger than all of their immediate neighbors.  <code>region</code> is a list of dimensions to consider.  <code>edges</code> is a boolean specifying whether to include the first and last elements of each dimension, or a tuple-of-Bool specifying edge behavior for each dimension separately.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L475-L483">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.findlocalminima" href="#Images.findlocalminima"><code>Images.findlocalminima</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Like <code>findlocalmaxima</code>, but returns the coordinates of the smallest elements.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L487-L489">source</a><br/></section><h3><a class="nav-anchor" id="Exposure-1" href="#Exposure-1">Exposure</a></h3><pre><code class="language-none">imhist
cliphist
histeq
adjust_gamma
imstretch
imadjustintensity
complement
histmatch
clahe</code></pre><h3><a class="nav-anchor" id="Spatial-transformations-and-resizing-1" href="#Spatial-transformations-and-resizing-1">Spatial transformations and resizing</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.imresize" href="#ImageTransformations.imresize"><code>ImageTransformations.imresize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imresize(img, sz) -&gt; imgr
imresize(img, inds) -&gt; imgr</code></pre><p>Change <code>img</code> to be of size <code>sz</code> (or to have indices <code>inds</code>). This interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter <code>img</code> first. For example:</p><pre><code class="language-none">σ = map((o,n)-&gt;0.75*o/n, size(img), sz)
kern = KernelFactors.gaussian(σ)   # from ImageFiltering
imgr = imresize(imfilter(img, kern, NA()), sz)</code></pre><p>See also <a href="function_reference.html#ImageTransformations.restrict"><code>restrict</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/tree/984146c3ccf2b4c57c0f85c4a481d5396ac1f1b9/src/resizing.jl#L170-L184">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.restrict" href="#ImageTransformations.restrict"><code>ImageTransformations.restrict</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">restrict(img[, region]) -&gt; imgr</code></pre><p>Reduce the size of <code>img</code> by two-fold along the dimensions listed in <code>region</code>, or all spatial coordinates if <code>region</code> is not specified.  It anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks.</p><p>See also <a href="function_reference.html#ImageTransformations.imresize"><code>imresize</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/tree/984146c3ccf2b4c57c0f85c4a481d5396ac1f1b9/src/resizing.jl#L1-L10">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageTransformations.warp" href="#ImageTransformations.warp"><code>ImageTransformations.warp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">warp(img, tform) -&gt; imgw</code></pre><p>Transform the coordinates of <code>img</code>, returning a new <code>imgw</code> satisfying <code>imgw[x] = img[tform(x)]</code>. <code>tform</code> should be defined using CoordinateTransformations.jl.</p><p><strong>Interpolation scheme</strong></p><p>At off-grid points, <code>imgw</code> is calculated by interpolation. The default is linear interpolation, used when <code>img</code> is a plain array, and <code>NaN</code> values are used to indicate locations for which <code>tform(x)</code> was outside the bounds of the input <code>img</code>. For more control over the interpolation scheme–-and how beyond-the-edge points are handled–-pass it in as an <code>AbstractExtrapolation</code> from Interpolations.jl.</p><p><strong>The meaning of the coordinates</strong></p><p>The output array <code>imgw</code> has indices that would result from applying <code>tform</code> to the indices of <code>img</code>. This can be very handy for keeping track of how pixels in <code>imgw</code> line up with pixels in <code>img</code>.</p><p>If you just want a plain array, you can &quot;strip&quot; the custom indices with <code>parent(imgw)</code>.</p><p><strong>Examples: a 2d rotation (see JuliaImages documentation for pictures)</strong></p><pre><code class="language-jlcon">julia&gt; using Images, CoordinateTransformations, TestImages, OffsetArrays

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; indices(img)
(Base.OneTo(512),Base.OneTo(768))

# Rotate around the center of `img`
julia&gt; tfm = recenter(RotMatrix(pi/4), center(img))
AffineMap([0.707107 -0.707107; 0.707107 0.707107], [347.01,-68.7554])

julia&gt; imgw = warp(img, tfm);

julia&gt; indices(imgw)
(-196:709,-68:837)

# Alternatively, specify the origin in the image itself
julia&gt; img0 = OffsetArray(img, -30:481, -384:383);  # origin near top of image

julia&gt; rot = LinearMap(RotMatrix(pi/4))
LinearMap([0.707107 -0.707107; 0.707107 0.707107])

julia&gt; imgw = warp(img0, rot);

julia&gt; indices(imgw)
(-293:612,-293:611)

julia&gt; imgr = parent(imgw);

julia&gt; indices(imgr)
(Base.OneTo(906),Base.OneTo(905))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/tree/984146c3ccf2b4c57c0f85c4a481d5396ac1f1b9/src/warp.jl#L29-L89">source</a><br/></section><h3><a class="nav-anchor" id="Image-statistics-1" href="#Image-statistics-1">Image statistics</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.minfinite" href="#Images.minfinite"><code>Images.minfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>m = minfinite(A)</code> calculates the minimum value in <code>A</code>, ignoring any values that are not finite (Inf or NaN).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L170-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.maxfinite" href="#Images.maxfinite"><code>Images.maxfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>m = maxfinite(A)</code> calculates the maximum value in <code>A</code>, ignoring any values that are not finite (Inf or NaN).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L188-L190">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.maxabsfinite" href="#Images.maxabsfinite"><code>Images.maxabsfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>m = maxabsfinite(A)</code> calculates the maximum absolute value in <code>A</code>, ignoring any values that are not finite (Inf or NaN).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L206-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.meanfinite" href="#Images.meanfinite"><code>Images.meanfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>M = meanfinite(img, region)</code> calculates the mean value along the dimensions listed in <code>region</code>, ignoring any non-finite values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L6-L8">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.ssd" href="#Images.ssd"><code>Images.ssd</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>s = ssd(A, B)</code> computes the sum-of-squared differences over arrays/images A and B</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L285">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.ssdn" href="#Images.ssdn"><code>Images.ssdn</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>s = ssdn(A, B)</code> computes the sum-of-squared differences over arrays/images A and B, normalized by array size</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L314">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.sad" href="#Images.sad"><code>Images.sad</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>s = sad(A, B)</code> computes the sum-of-absolute differences over arrays/images A and B</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L288">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.sadn" href="#Images.sadn"><code>Images.sadn</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>s = sadn(A, B)</code> computes the sum-of-absolute differences over arrays/images A and B, normalized by array size</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L318">source</a><br/></section><h3><a class="nav-anchor" id="Morphological-operations-1" href="#Morphological-operations-1">Morphological operations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.dilate" href="#Images.dilate"><code>Images.dilate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imgd = dilate(img, [region])</code></pre><p>perform a max-filter over nearest-neighbors. The default is 8-connectivity in 2d, 27-connectivity in 3d, etc. You can specify the list of dimensions that you want to include in the connectivity, e.g., <code>region = [1,2]</code> would exclude the third dimension from filtering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L608-L617">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.erode" href="#Images.erode"><code>Images.erode</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imge = erode(img, [region])</code></pre><p>perform a min-filter over nearest-neighbors. The default is 8-connectivity in 2d, 27-connectivity in 3d, etc. You can specify the list of dimensions that you want to include in the connectivity, e.g., <code>region = [1,2]</code> would exclude the third dimension from filtering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L619-L628">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.opening" href="#Images.opening"><code>Images.opening</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgo = opening(img, [region])</code> performs the <code>opening</code> morphology operation, equivalent to <code>dilate(erode(img))</code>. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L667-L670">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.closing" href="#Images.closing"><code>Images.closing</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgc = closing(img, [region])</code> performs the <code>closing</code> morphology operation, equivalent to <code>erode(dilate(img))</code>. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L674-L677">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.tophat" href="#Images.tophat"><code>Images.tophat</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgth = tophat(img, [region])</code> performs <code>top hat</code> of an image, which is defined as the image minus its morphological opening. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L681-L685">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.bothat" href="#Images.bothat"><code>Images.bothat</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgbh = bothat(img, [region])</code> performs <code>bottom hat</code> of an image, which is defined as its morphological closing minus the original image. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L688-L692">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.morphogradient" href="#Images.morphogradient"><code>Images.morphogradient</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgmg = morphogradient(img, [region])</code> returns morphological gradient of the image, which is the difference between the dilation and the erosion of a given image. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L695-L699">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.morpholaplace" href="#Images.morpholaplace"><code>Images.morpholaplace</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>imgml = morpholaplace(img, [region])</code> performs <code>Morphological Laplacian</code> of an image, which is defined as the arithmetic difference between the internal and the external gradient. <code>region</code> allows you to control the dimensions over which this operation is performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L702-L706">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.label_components" href="#Images.label_components"><code>Images.label_components</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">label = label_components(tf, [connectivity])
label = label_components(tf, [region])</code></pre><p>Find the connected components in a binary array <code>tf</code>. There are two forms that <code>connectivity</code> can take:</p><ul><li><p>It can be a boolean array of the same dimensionality as <code>tf</code>, of size 1 or 3</p></li></ul><p>along each dimension. Each entry in the array determines whether a given neighbor is used for connectivity analyses. For example, <code>connectivity = trues(3,3)</code> would use 8-connectivity and test all pixels that touch the current one, even the corners.</p><ul><li><p>You can provide a list indicating which dimensions are used to</p></li></ul><p>determine connectivity. For example, <code>region = [1,3]</code> would not test neighbors along dimension 2 for connectivity. This corresponds to just the nearest neighbors, i.e., 4-connectivity in 2d and 6-connectivity in 3d.</p><p>The default is <code>region = 1:ndims(A)</code>.</p><p>The output <code>label</code> is an integer array, where 0 is used for background pixels, and each connected region gets a different integer index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L3-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.component_boxes" href="#Images.component_boxes"><code>Images.component_boxes</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>component_boxes(labeled_array)</code> -&gt; an array of bounding boxes for each label, including the background label 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L228">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.component_lengths" href="#Images.component_lengths"><code>Images.component_lengths</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>component_lengths(labeled_array)</code> -&gt; an array of areas (2D), volumes (3D), etc. for each label, including the background label 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L246">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.component_indices" href="#Images.component_indices"><code>Images.component_indices</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>component_indices(labeled_array)</code> -&gt; an array of pixels for each label, including the background label 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L255">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.component_subscripts" href="#Images.component_subscripts"><code>Images.component_subscripts</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>component_subscripts(labeled_array)</code> -&gt; an array of pixels for each label, including the background label 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L264">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.component_centroids" href="#Images.component_centroids"><code>Images.component_centroids</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>component_centroids(labeled_array)</code> -&gt; an array of centroids for each label, including the background label 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/connected.jl#L274">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.FeatureTransform.feature_transform" href="#Images.FeatureTransform.feature_transform"><code>Images.FeatureTransform.feature_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">feature_transform(I::AbstractArray{Bool, N}, [w=nothing]) -&gt; F</code></pre><p>Compute the feature transform of a binary image <code>I</code>, finding the closest &quot;feature&quot; (positions where <code>I</code> is <code>true</code>) for each location in <code>I</code>.  Specifically, <code>F[i]</code> is a <code>CartesianIndex</code> encoding the position closest to <code>i</code> for which <code>I[F[i]]</code> is <code>true</code>.  In cases where two or more features in <code>I</code> have the same distance from <code>i</code>, an arbitrary feature is chosen. If <code>I</code> has no <code>true</code> values, then all locations are mapped to an index where each coordinate is <code>typemin(Int)</code>.</p><p>Optionally specify the weight <code>w</code> assigned to each coordinate.  For example, if <code>I</code> corresponds to an image where voxels are anisotropic, <code>w</code> could be the voxel spacing along each coordinate axis. The default value of <code>nothing</code> is equivalent to <code>w=(1,1,...)</code>.</p><p>See also: <a href="function_reference.html#Images.FeatureTransform.distance_transform"><code>distance_transform</code></a>.</p><p><strong>Citation</strong></p><p>&#39;A Linear Time Algorithm for Computing Exact Euclidean Distance Transforms of Binary Images in Arbitrary Dimensions&#39; <a href="DOI: 10.1109/TPAMI.2003.1177156">Maurer et al., 2003</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/bwdist.jl#L5-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.FeatureTransform.distance_transform" href="#Images.FeatureTransform.distance_transform"><code>Images.FeatureTransform.distance_transform</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">distance_transform(F::AbstractArray{CartesianIndex}, [w=nothing]) -&gt; D</code></pre><p>Compute the distance transform of <code>F</code>, where each element <code>F[i]</code> represents a &quot;target&quot; or &quot;feature&quot; location assigned to <code>i</code>. Specifically, <code>D[i]</code> is the distance between <code>i</code> and <code>F[i]</code>. Optionally specify the weight <code>w</code> assigned to each coordinate; the default value of <code>nothing</code> is equivalent to <code>w=(1,1,...)</code>.</p><p>See also: <a href="function_reference.html#Images.FeatureTransform.feature_transform"><code>feature_transform</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/bwdist.jl#L45-L55">source</a><br/></section><h3><a class="nav-anchor" id="Interpolation-1" href="#Interpolation-1">Interpolation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.bilinear_interpolation" href="#Images.bilinear_interpolation"><code>Images.bilinear_interpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">P = bilinear_interpolation(img, r, c)</code></pre><p>Bilinear Interpolation is used to interpolate functions of two variables on a rectilinear 2D grid.</p><p>The interpolation is done in one direction first and then the values obtained are used to do the interpolation in the second direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L827-L838">source</a><br/></section><h3><a class="nav-anchor" id="Integral-Images-1" href="#Integral-Images-1">Integral Images</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.integral_image" href="#Images.integral_image"><code>Images.integral_image</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">integral_img = integral_image(img)</code></pre><p>Returns the integral image of an image. The integral image is calculated by assigning to each pixel the sum of all pixels above it and to its left, i.e. the rectangle from (1, 1) to the pixel. An integral image is a data structure which helps in efficient calculation of sum of pixels in a rectangular subset of an image. See <code>boxdiff</code> for more information.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L771-L781">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.boxdiff" href="#Images.boxdiff"><code>Images.boxdiff</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sum = boxdiff(integral_image, ytop:ybot, xtop:xbot)
sum = boxdiff(integral_image, CartesianIndex(tl_y, tl_x), CartesianIndex(br_y, br_x))
sum = boxdiff(integral_image, tl_y, tl_x, br_y, br_x)</code></pre><p>An integral image is a data structure which helps in efficient calculation of sum of pixels in a rectangular subset of an image. It stores at each pixel the sum of all pixels above it and to its left. The sum of a window in an image can be directly calculated using four array references of the integral image, irrespective of the size of the window, given the <code>yrange</code> and <code>xrange</code> of the window. Given an integral image -</p><pre><code class="language-none">    A - - - - - - B -
    - * * * * * * * -
    - * * * * * * * -
    - * * * * * * * -
    - * * * * * * * -
    - * * * * * * * -
    C * * * * * * D -
    - - - - - - - - -</code></pre><p>The sum of pixels in the area denoted by * is given by S = D + A - B - C.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L792-L815">source</a><br/></section><h3><a class="nav-anchor" id="Pyramids-1" href="#Pyramids-1">Pyramids</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.gaussian_pyramid" href="#Images.gaussian_pyramid"><code>Images.gaussian_pyramid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pyramid = gaussian_pyramid(img, n_scales, downsample, sigma)</code></pre><p>Returns a  gaussian pyramid of scales <code>n_scales</code>, each downsampled by a factor <code>downsample</code> and <code>sigma</code> for the gaussian kernel.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L872-L880">source</a><br/></section><h3><a class="nav-anchor" id="Phantoms-1" href="#Phantoms-1">Phantoms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Images.shepp_logan" href="#Images.shepp_logan"><code>Images.shepp_logan</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">phantom = shepp_logan(N,[M]; highContrast=true)</code></pre><p>output the NxM Shepp-Logan phantom, which is a standard test image usually used for comparing image reconstruction algorithms in the field of computed tomography (CT) and magnetic resonance imaging (MRI). If the argument M is omitted, the phantom is of size NxN. When setting the keyword argument <code>highConstrast</code> to false, the CT version of the phantom is created. Otherwise, the high contrast MRI version is calculated.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/Images.jl/tree/29601ec723590380262f22d2e70d50b87c6b506b/src/algorithms.jl#L723-L734">source</a><br/></section><h2><a class="nav-anchor" id="Image-metadata-utilities-1" href="#Image-metadata-utilities-1">Image metadata utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageMetadata.ImageMeta" href="#ImageMetadata.ImageMeta"><code>ImageMetadata.ImageMeta</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>ImageMeta</code> is an AbstractArray that can have metadata, stored in a dictionary.</p><p>Construct an image with <code>ImageMeta(A, props)</code> (for a properties dictionary <code>props</code>), or with <code>Image(A, prop1=val1, prop2=val2, ...)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L36-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.data" href="#ImageCore.data"><code>ImageCore.data</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">data(img::ImageMeta) -&gt; array</code></pre><p>Extract the data from <code>img</code>, omitting the properties dictionary. <code>array</code> shares storage with <code>img</code>, so changes to one affect the other.</p><p>See also: <a href="function_reference.html#ImageMetadata.properties"><code>properties</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L189-L197">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageMetadata.properties" href="#ImageMetadata.properties"><code>ImageMetadata.properties</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">properties(imgmeta) -&gt; props</code></pre><p>Extract the properties dictionary <code>props</code> for <code>imgmeta</code>. <code>props</code> shares storage with <code>img</code>, so changes to one affect the other.</p><p>See also: <a href="function_reference.html#ImageCore.data"><code>data</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L217-L224">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageMetadata.copyproperties" href="#ImageMetadata.copyproperties"><code>ImageMetadata.copyproperties</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">copyproperties(img::ImageMeta, data) -&gt; imgnew</code></pre><p>Create a new &quot;image,&quot; copying the properties dictionary of <code>img</code> but using the data of the AbstractArray <code>data</code>. Note that changing the properties of <code>imgnew</code> does not affect the properties of <code>img</code>.</p><p>See also: <a href="function_reference.html#ImageMetadata.shareproperties"><code>shareproperties</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L144-L152">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageMetadata.shareproperties" href="#ImageMetadata.shareproperties"><code>ImageMetadata.shareproperties</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">shareproperties(img::ImageMeta, data) -&gt; imgnew</code></pre><p>Create a new &quot;image,&quot; reusing the properties dictionary of <code>img</code> but using the data of the AbstractArray <code>data</code>. The two images have synchronized properties; modifying one also affects the other.</p><p>See also: <a href="function_reference.html#ImageMetadata.copyproperties"><code>copyproperties</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L156-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageCore.spatialproperties" href="#ImageCore.spatialproperties"><code>ImageCore.spatialproperties</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spatialproperties(img)</code></pre><p>Return a vector of strings, containing the names of properties that have been declared &quot;spatial&quot; and hence should be permuted when calling <code>permutedims</code>.  Declare such properties like this:</p><pre><code class="language-none">img[&quot;spatialproperties&quot;] = [&quot;spacedirections&quot;]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageMetadata.jl/tree/f7c96fa8f7800d127324e3d9441c4228c218858e/src/ImageMetadata.jl#L325-L333">source</a><br/></section><footer><hr/><a class="previous" href="troubleshooting.html"><span class="direction">Previous</span><span class="title">Installation troubleshooting</span></a><a class="next" href="api_comparison.html"><span class="direction">Next</span><span class="title">Comparison with other image processing frameworks</span></a></footer></article></body></html>
